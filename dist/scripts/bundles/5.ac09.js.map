{"version":3,"sources":["webpack:///./src/scripts/modify-templates.js"],"names":["changeTemplateFill","newFun","MeasuredTemplate","prototype","refresh","toString","replace","Function","Hooks","on","app","html","data","querySelector","dataset","type"],"mappings":";;;;6DAAe,SAASA,IAKtB,IAEIC,EAFSC,iBAAiBC,UAAUC,QAAQC,WAE5BC,QAAQ,6CAA8C,moEAkD1EJ,iBAAiBC,UAAUC,QAAUG,SAAS,mCAAmCN,MAA5CM,GAErCC,MAAMC,GAAG,+BAAgC,CAACC,EAAKC,EAAMC,KACnDD,EAAK,GAAGE,cAAc,gBAAgBC,QAAQC,KAAO,eA5DzD","file":"bundles/5.ac09.js","sourcesContent":["export default function changeTemplateFill() {\n\n  // #MonkeyPatchingFTW\n  // better than stealing the code, replacing one line and then release it under a/the wrong license..\n  // Disadvantage: could need more fixing on updates. At least i didn#t make it line based like Kakaroto.. :P\n  let oldFun = MeasuredTemplate.prototype.refresh.toString();\n  \n  let newFun = oldFun.replace(/this.template.beginTextureFill\\(\\{.*\\}\\);/s, `{\n      let mat = PIXI.Matrix.IDENTITY;\n      // rectangle\n      if (this.shape.width && this.shape.height)\n        mat.scale(this.shape.width / this.texture.width, this.shape.height / this.texture.height);\n      else if (this.shape.radius) {\n        mat.scale(this.shape.radius * 2 / this.texture.height, this.shape.radius * 2 / this.texture.width)\n        // Circle center is texture start...\n        mat.translate(-this.shape.radius, -this.shape.radius);\n      } else if (this.data.t === \"ray\") {\n        const d = canvas.dimensions,\n              height = this.data.width * d.size / d.distance,\n              width = this.data.distance * d.size / d.distance;\n        mat.scale(width / this.texture.width, height / this.texture.height);\n        mat.translate(0, -height * 0.5);\n\n        mat.rotate(toRadians(this.data.direction));\n      } else {// cone\n        const d = canvas.dimensions;\n    \n        // Extract and prepare data\n        let {direction, distance, angle} = this.data;\n        distance *= (d.size / d.distance);\n        direction = toRadians(direction);\n        const width = this.data.distance * d.size / d.distance;\n\n        const angles = [(angle/-2), (angle/2)];\n        distance = distance * Math.cos(toRadians(angle/2));\n    \n        // Get the cone shape as a polygon\n        const rays = angles.map(a => Ray.fromAngle(0, 0, direction + toRadians(a), distance+1));\n        const height = Math.sqrt((rays[0].B.x - rays[1].B.x) * (rays[0].B.x - rays[1].B.x)\n                        + (rays[0].B.y - rays[1].B.y) * (rays[0].B.y - rays[1].B.y));\n        mat.scale(width / this.texture.width, height / this.texture.height);\n        mat.translate(0, -height/2)\n        mat.rotate(toRadians(this.data.direction));\n      }\n      this.template.beginTextureFill({\n        texture: this.texture,\n        matrix: mat,\n        alpha: 0.8\n      });\n      // move into draw or so\n      const source = getProperty(this.texture, \"baseTexture.resource.source\")\n      if ( source && (source.tagName === \"VIDEO\") ) {\n        source.loop = true;\n        source.muted = true;\n        game.video.play(source);\n      }\n    }`);\n  MeasuredTemplate.prototype.refresh = Function(`\"use strict\"; return ( function ${newFun} )`)();\n\n  Hooks.on('renderMeasuredTemplateConfig', (app, html, data) => {\n    html[0].querySelector('.file-picker').dataset.type = 'imagevideo'\n  });\n}"],"sourceRoot":""}