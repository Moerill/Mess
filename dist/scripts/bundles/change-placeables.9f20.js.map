{"version":3,"sources":["webpack:///./src/scripts/change-placeables.js"],"names":["onDragLeftMove","event","clones","destination","origin","originalEvent","data","canvas","_onDragCanvasPan","dx","x","dy","y","snap","previous","momentumThreshold","lambda","prev","prevMomentum","momentum","prevV","v","shiftKey","c","dest","_original","grid","getSnappedPosition","this","layer","options","gridPrecision","refresh","changePlaceables","PlaceableObject","prototype","_onDragLeftMove"],"mappings":";;;;6DAAA,SAASA,EAAeC,GACvB,MAAM,OAACC,EAAM,YAAEC,EAAW,OAAEC,EAAM,cAAEC,GAAiBJ,EAAMK,KAG3DC,OAAOC,iBAAiBH,GAGxB,MAAMI,EAAKN,EAAYO,EAAIN,EAAOM,EAC5BC,EAAKR,EAAYS,EAAIR,EAAOQ,EAElC,IAAIC,GAAO,EACX,GAAIZ,EAAMK,KAAKQ,SAAU,CAIxB,MAAMC,EAAoB,GAIpBC,EAAS,GACTC,EAAOhB,EAAMK,KAAKQ,SAClBI,EAAejB,EAAMK,KAAKa,UAAY,EACtCC,EAAQnB,EAAMK,KAAKe,GAAK,CAACX,EAAG,EAAGE,EAAG,GAClCS,EAAI,CACTX,EAAGP,EAAYO,EAAIO,EAAKP,EACxBE,EAAGT,EAAYS,EAAIK,EAAKL,GAEnBO,EAAW,CAChBT,EAAGW,EAAEX,EAAIU,EAAMV,EACfE,EAAGS,EAAET,EAAIQ,EAAMR,GAGhBX,EAAMK,KAAKa,SAAYA,EAAST,EAAIS,EAAST,EAAIS,EAASP,EAAIO,EAASP,EAAKM,EAAeF,EAC3FH,GAAQZ,EAAMqB,UAAYrB,EAAMK,KAAKa,SAAWJ,EAGjDd,EAAMK,KAAKQ,SAAWX,EAGtB,IAAM,IAAIoB,KAAKrB,GAAU,GAAK,CAC7B,IAAIsB,EAAO,CAACd,EAAGa,EAAEE,UAAUnB,KAAKI,EAAID,EAAIG,EAAGW,EAAEE,UAAUnB,KAAKM,EAAID,GAC3DE,IACJW,EAAOjB,OAAOmB,KAAKC,mBAAmBH,EAAKd,EAAGc,EAAKZ,EAAGgB,KAAKC,MAAMC,QAAQC,gBAE1ER,EAAEjB,KAAKI,EAAIc,EAAKd,EAChBa,EAAEjB,KAAKM,EAAIY,EAAKZ,EAChBW,EAAES,WAIW,SAASC,IACvBC,gBAAgBC,UAAUC,gBAAkBpC,EAnD7C","file":"bundles/change-placeables.9f20.js","sourcesContent":["function onDragLeftMove(event) {\n\tconst {clones, destination, origin, originalEvent} = event.data;\n\n\t// Pan the canvas if the drag event approaches the edge\n\tcanvas._onDragCanvasPan(originalEvent);\n\n\t// Determine dragged distance\n\tconst dx = destination.x - origin.x;\n\tconst dy = destination.y - origin.y;\n\n\tlet snap = false;\n\tif (event.data.previous) {\n\t\t// Interesting would be here how this all behaves for different monitor sizes/performances and when Atro possibly introduces more adaptive rates for mosue movement. \n\t\t// Why? Because currently i just set the timedifferences between function calls to 1. So for 60Hz it behaves same as 30Hz although for 30Hz the distance travelled could be bigger.\n\t\t// All this because i don't want divisions in here for the moment....\n\t\tconst momentumThreshold = 30;\n\t\t// smaller lambda means less \"memory\" => current momentum does have more impact\n\t\t// => more jumping around between snapping and not\n\t\t// but higher means more waiting/slow movement time for it to snap\n\t\tconst lambda = 0.8;\n\t\tconst prev = event.data.previous;\n\t\tconst prevMomentum = event.data.momentum || 0;\n\t\tconst prevV = event.data.v || {x: 0, y: 0};\n\t\tconst v = {\n\t\t\tx: destination.x - prev.x,\n\t\t\ty: destination.y - prev.y\n\t\t}\n\t\tconst momentum = {\n\t\t\tx: v.x - prevV.x,\n\t\t\ty: v.y - prevV.y\n\t\t};\n\n\t\tevent.data.momentum = (momentum.x * momentum.x + momentum.y * momentum.y) + prevMomentum * lambda;\n\t\tsnap = !event.shiftKey && event.data.momentum < momentumThreshold;\n\t}\n\n\tevent.data.previous = destination;\n\n\t// Update the position of each clone\n\tfor ( let c of clones || [] ) {\n\t\tlet dest = {x: c._original.data.x + dx, y: c._original.data.y + dy};\n\t\tif ( snap ) {\n\t\t\tdest = canvas.grid.getSnappedPosition(dest.x, dest.y, this.layer.options.gridPrecision);\n\t\t}\n\t\tc.data.x = dest.x;\n\t\tc.data.y = dest.y;\n\t\tc.refresh();\n\t}\n}\n\nexport default function changePlaceables() {\n\tPlaceableObject.prototype._onDragLeftMove = onDragLeftMove;\n\t// Change got bigger than expected, so.. complete swap it is\n}"],"sourceRoot":""}