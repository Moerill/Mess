(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{"./src/scripts/modify-templates.js":
/*!*****************************************!*\
  !*** ./src/scripts/modify-templates.js ***!
  \*****************************************/
/*! exports provided: default */function(t,e,a){"use strict";function s(){let t=MeasuredTemplate.prototype.refresh.toString().replace(/this\.template\.beginTextureFill\(\{[\s\S]*\}\)\;/,'{\n      let mat = PIXI.Matrix.IDENTITY;\n      // rectangle\n      if (this.shape.width && this.shape.height)\n        mat.scale(this.shape.width / this.texture.width, this.shape.height / this.texture.height);\n      else if (this.shape.radius) {\n        mat.scale(this.shape.radius * 2 / this.texture.height, this.shape.radius * 2 / this.texture.width)\n        // Circle center is texture start...\n        mat.translate(-this.shape.radius, -this.shape.radius);\n      } else if (this.data.t === "ray") {\n        const d = canvas.dimensions,\n              height = this.data.width * d.size / d.distance,\n              width = this.data.distance * d.size / d.distance;\n        mat.scale(width / this.texture.width, height / this.texture.height);\n        mat.translate(0, -height * 0.5);\n\n        mat.rotate(toRadians(this.data.direction));\n      } else {// cone\n        const d = canvas.dimensions;\n    \n        // Extract and prepare data\n        let {direction, distance, angle} = this.data;\n        distance *= (d.size / d.distance);\n        direction = toRadians(direction);\n        const width = this.data.distance * d.size / d.distance;\n\n        const angles = [(angle/-2), (angle/2)];\n        distance = distance * Math.cos(toRadians(angle/2));\n    \n        // Get the cone shape as a polygon\n        const rays = angles.map(a => Ray.fromAngle(0, 0, direction + toRadians(a), distance+1));\n        const height = Math.sqrt((rays[0].B.x - rays[1].B.x) * (rays[0].B.x - rays[1].B.x)\n                        + (rays[0].B.y - rays[1].B.y) * (rays[0].B.y - rays[1].B.y));\n        mat.scale(width / this.texture.width, height / this.texture.height);\n        mat.translate(0, -height/2)\n        mat.rotate(toRadians(this.data.direction));\n      }\n      this.template.beginTextureFill({\n        texture: this.texture,\n        matrix: mat,\n        alpha: 0.8\n      });\n      // move into draw or so\n      const source = getProperty(this.texture, "baseTexture.resource.source")\n      if ( source && (source.tagName === "VIDEO") ) {\n        source.loop = true;\n        source.muted = true;\n        game.video.play(source);\n      }\n    }');MeasuredTemplate.prototype.refresh=Function(`"use strict"; return ( function ${t} )`)(),Hooks.on("renderMeasuredTemplateConfig",(t,e,a)=>{e[0].querySelector(".file-picker").dataset.type="imagevideo"})}a.r(e),a.d(e,"default",(function(){return s}))}}]);
//# sourceMappingURL=5.fe80.js.map